defmodule CHAT.ASN1 do

  def dir(), do: :application.get_env(:ca, :bundle, "priv/apple/")

  def emitSequenceDefinition(name,fields,ctor,decoder,encoder) do
"""
// This file is autogenerated. Do not edit.

import Foundation
import SwiftASN1
import Crypto

@usableFromInline struct #{name}: DERImplicitlyTaggable, Hashable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .sequence }\n#{fields}
    #{ctor}
    #{decoder}
    #{encoder}
}
"""
  end

  def emitSequenceDecoder(fields, name, args), do:
"""
@inlinable init(derEncoded root: ASN1Node, withIdentifier identifier: ASN1Identifier) throws {
        self = try DER.sequence(root, identifier: identifier) { nodes in\n#{fields}
            return #{normalizeName(name)}(#{args})
        }
    }
"""

  def emitSequenceEncoder(fields), do:
"""
@inlinable func serialize(into coder: inout DER.Serializer, withIdentifier identifier: ASN1Identifier) throws {
        try coder.appendConstructedNode(identifier: identifier) { coder in\n#{fields}
        }
    }
"""

  def parseFieldName({:contentType, {:Externaltypereference,_,moduleFile, fieldName}}), do: "#{fieldName}"
  def parseFieldName(fieldName),                                                        do: "#{fieldName}"

  def parseFieldType(name,fieldName,{:pt, {_,_,_,fieldType}, _}) when is_atom(fieldType),              do: "#{fieldType}"
  def parseFieldType(name,fieldName,{:"BIT STRING", _}),                                               do: "ASN1BitString"
  def parseFieldType(name,fieldName,{:"SEQUENCE", _, _, _, _}),                                        do: bin(name) <> "_" <> bin(fieldName) <> "_Sequence"
  def parseFieldType(name,fieldName,{:"SEQUENCE OF", _}),                                              do: "ASN1SequenceOf"
  def parseFieldType(name,fieldName,{:ANY_DEFINED_BY, fieldType}) when is_atom(fieldType),             do: "ASN1Any"
  def parseFieldType(name,fieldName,{:contentType, {:Externaltypereference,_,moduleFile, fieldType}}), do: "#{fieldType}"
  def parseFieldType(name,fieldName,{:Externaltypereference,_,moduleFile, fieldType}),                 do: "#{fieldType}"
  def parseFieldType(name,fieldName,{:ObjectClassFieldType,_,_,[{_,fieldType}],_}),                    do: "#{fieldType}"
  def parseFieldType(name,fieldName,{:ComponentType,_,_,{:type,_,objectClass,elementSet,[],:no},optional,_,_}), do: parseFieldType(name, fieldName, objectClass)
  def parseFieldType(name,fieldName,{:"SET OF",{:type,_,{:"SEQUENCE", _, _, _,fieldTypes},_,_,_}}),    do: 
      Enum.join(:lists.map(fn x -> parseFieldType(name, fieldName, x) end, fieldTypes), "->")
  def parseFieldType(name,fieldName,{:"SET OF",{:type,_,external,_,_,_}}),                             do: parseFieldType(name, fieldName, external)
  def parseFieldType(name,fieldName,{:CHOICE,choices}),                                                do: bin(name) <> "_" <> bin(fieldName) <> "_Choice"
  def parseFieldType(name,fieldName,:BOOLEAN),                                                         do: "Bool"
  def parseFieldType(name,fieldName,fieldType) when is_atom(fieldType),                                do: "#{fieldType}"
  def parseFieldType(name,fieldName,fieldType) do
      :io.format 'unknown: ~p',[{name, fieldType}]
      "#{name}"
  end

  def emitFields(name, pad, fields) when is_list(fields) do
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         field = parseFieldType(name, fieldName, fieldType)
         String.duplicate(" ", pad) <>
         emitSequenceElement(parseFieldName(fieldName),
                             substituteType(lookup(field)))
       _ ->  ""
      end, fields), "")
  end

  def lookup(name) do
      x = :application.get_env(:asn1scg, bin(name), bin(name))
      :logger.info 'lookup: ~p', [name, x]
      bin(x)
  end

  def substituteType("INTEGER"),      do: "ArraySlice<UInt8>"
  def substituteType("OCTET STRING"), do: "ASN1OctetString"
  def substituteType("BIT STRING"),   do: "ASN1BitString"
  def substituteType("BOOLEAN"),      do: "Bool"
  def substituteType(t),              do: t

  def emitDecoderBodyElement(name, type), do: "let #{name} = try #{type}(derEncoded: &nodes)"
  def emitEncoderBodyElement(name),       do: "try coder.serialize(self.#{name})"
  def emitCtorBodyElement(name),          do: "self.#{name} = #{name}"
  def emitCtorParam(name, type),          do: "#{name}: #{type}"
  def emitArg(name),                      do: "#{name}: #{name}"
  def emitSequenceElement(name, type),    do: "@usableFromInline var #{name}: #{type}\n"

  def emitCtor(params,fields), do: "@inlinable init(#{params}) {\n#{fields}\n    }"

  def emitCtorBody(fields), do:
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         String.duplicate(" ", 8) <> emitCtorBodyElement(parseFieldName(fieldName))
       _ ->  ""
      end, fields), "\n")

  def emitEncoderBody(fields), do:
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         String.duplicate(" ", 12) <> emitEncoderBodyElement(parseFieldName(fieldName))
       _ ->  ""
      end, fields), "\n")

  def emitDecoderBody(name,fields), do:
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         String.duplicate(" ", 12) <>
         emitDecoderBodyElement(parseFieldName(fieldName),
                                substituteType(lookup(parseFieldType(name,fieldName,fieldType))))
       _ ->  ""
      end, fields), "\n")

  def emitParams(name,fields) when is_list(fields) do
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         emitCtorParam(parseFieldName(fieldName),
                       substituteType(lookup(parseFieldType(name,fieldName,fieldType))))
       _ ->  ""
      end, fields), ", ")
  end

  def emitArgs(fields) when is_list(fields) do
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         emitArg(parseFieldName(fieldName))
       _ ->  ""
      end, fields), ", ")
  end

  def bin(x) when is_atom(x), do: :erlang.atom_to_binary x
  def bin(x) when is_list(x), do: :erlang.list_to_binary x
  def bin(x), do: x

  def compile_all() do
      {:ok, files} = :file.list_dir dir()
      :lists.map(fn file -> compile(false, dir() <> :erlang.list_to_binary(file))  end, files)
      :lists.map(fn file -> compile(true,  dir() <> :erlang.list_to_binary(file))  end, files)
      :ok
  end

  def save(flag, name, res) do
      case flag do
           true -> 
               file = normalizeName(name) <> ".swift"
               :logger.info 'write: ~p', [file]
               :file.write_file file, res
           false -> []
      end
  end

  def compileType(pos, name, typeDefinition, save \\ true) do
      case typeDefinition do
           {:type, _, {typeASN1, _, _, _, fields}, _, _, :no} -> 
               res = case typeASN1 do
                 :ObjectClassFieldType ->
                    :logger.info('ASN.1 name ~p type ~p is not supported.', [name, typeDefinition])
                 :SEQUENCE ->
                    emitSequenceDefinition(
                       normalizeName(name),
                       emitFields(name, 4, fields),
                       emitCtor(emitParams(name,fields), emitCtorBody(fields)),
                       emitSequenceDecoder(emitDecoderBody(name, fields), name, emitArgs(fields)),
                       emitSequenceEncoder(emitEncoderBody(fields)))
                 _ -> :logger.info('ASN.1 name ~p type ~p is not supported.', [name, fields])
               end
               save(save, name, res)
           {:type, _, {:"SEQUENCE OF", type}, [], [], :no} ->
               :skip
           {:type, _, {:CHOICE, type}, [], [], :no} ->
               :skip
           {:type, x, :INTEGER, [], [], :no} ->
               :application.set_env(:asn1scg, bin(name), "INTEGER")
               :skip
           {:type, _, {:INTEGER, file}, [], [], :no} ->
               :logger.info 'INT ENUM: ~p ~p', [name, file]
               :skip
           {:type, _, :"OCTET STRING", [], [], :no} ->
               :application.set_env(:asn1scg, bin(name), "OCTET STRING")
               :skip
           {:type, _, :"BIT STRING", [], [], :no} ->
               :skip
           {:type, _, {:"BIT STRING",_}, [], [], :no} ->
               :application.set_env(:asn1scg, bin(name), "BIT STRING")
               :skip
           {:type, _, {:"SET OF", type}, elementSet, [], :no} ->
               :skip
           {:type, _, {:Externaltypereference, _, _, name}, [], [], _} ->
               :skip
           {:type, _, {:pt, _, _}, [], [], _} ->
               :skip
           {:ObjectSet, _, _, _, elementSet} ->
               :skip
           {:type, _, :"OBJECT IDENTIFIER", _, _, :no} -> 
               :skip
           {:Object, _, val} -> 
               :skip
           {:Object, _, _, _} -> 
               :skip
           file ->
               :logger.info 'unknown: ~p ~p', [name, file]
               :skip
      end 
  end

  def normalizeName(name), do: Enum.join(String.split("#{name}", "-"), "")

  def dumpValue(pos, name, type, value, mod), do: []
  def dumpClass(pos, name, mod, type), do: []
  def dumpPType(pos, name, args, type), do: []
  def dumpModule(pos, name, defid, tagdefault, exports, imports), do: []

  def compile(save, file \\ "priv/proto/CHAT.asn1") do
      tokens = :asn1ct_tok.file file
      {:ok, mod} = :asn1ct_parser2.parse file, tokens
#      :io.format '~p', [mod]
      {:module, pos, name, defid, tagdefault, exports, imports, _, typeorval} = mod
      :lists.map(fn
         {:typedef,  _, pos, name, type} -> compileType(pos, name, type, save)
         {:ptypedef, _, pos, name, args, type} -> dumpPType(pos, name, args, type)
         {:classdef, _, pos, name, mod, type} -> dumpClass(pos, name, mod, type)
         {:valuedef, _, pos, name, type, value, mod} -> dumpValue(pos, name, type, value, mod)
      end, typeorval)
      dumpModule(pos, name, defid, tagdefault, exports, imports)
  end

end
