defmodule CHAT.ASN1 do

  def dir(), do: :application.get_env(:ca, :bundle, "priv/apple/")

  def parseFieldName({:contentType, {:Externaltypereference,_,moduleFile, fieldName}}), do: "#{fieldName}"
  def parseFieldName(fieldName), do: "#{fieldName}"

  def parseFieldType(name,field,{:pt, {_,_,_,fieldType}, _}) when is_atom(fieldType), do: "#{fieldType}"
  def parseFieldType(name,field,{:ANY_DEFINED_BY, fieldType}) when is_atom(fieldType), do: "ASN1Any"
  def parseFieldType(name,field,{:contentType, {:Externaltypereference,_,moduleFile, fieldType}}), do: "#{fieldType}"
  def parseFieldType(name,field,{:Externaltypereference,_,moduleFile, fieldType}), do: "#{fieldType}"
  def parseFieldType(name,field,{:ObjectClassFieldType,_,_,[{_,fieldType}],_}), do: "#{fieldType}"
  def parseFieldType(name,field,{:ComponentType,_,_,{:type,_,oc,_,[],:no},opt,_,_}), do: parseFieldType(name, field, oc)
  def parseFieldType(name,field,{:SEQUENCE, _, _, _, _}), do: bin(name) <> "_" <> bin(field) <> "_Sequence"
  def parseFieldType(name,field,{:CHOICE,choices}), do: bin(name) <> "_" <> bin(field) <> "_Choice"
  def parseFieldType(name,field,{:"BIT STRING", _}), do: "ASN1BitString"
  def parseFieldType(name,field,{:"SEQUENCE OF", _}), do: "ASN1SequenceOf"
  def parseFieldType(name,field,{:"SET OF",{:type,_,external,_,_,_}}), do: parseFieldType(name, field, external)
  def parseFieldType(name,field,{:"SET OF",{:type,_,{:"SEQUENCE", _, _, _,fieldTypes},_,_,_}}), do: 
      Enum.join(:lists.map(fn x -> parseFieldType(name, field, x) end, fieldTypes), "->")
  def parseFieldType(name,field,"BOOLEAN"), do: "Bool"
  def parseFieldType(name,field,fieldType) when is_atom(fieldType), do: "#{fieldType}"
  def parseFieldType(name,field,fieldType), do: "#{name}"

  def substituteType("INTEGER"),      do: "ArraySlice<UInt8>"
  def substituteType("OCTET STRING"), do: "ASN1OctetString"
  def substituteType("BIT STRING"),   do: "ASN1BitString"
  def substituteType("BOOLEAN"),      do: "Bool"
  def substituteType(t),              do: t

  def emitDecoderBodyElement(name, type), do: "let #{name} = try #{type}(derEncoded: &nodes)"
  def emitEncoderBodyElement(name),       do: "try coder.serialize(self.#{name})"
  def emitCtorBodyElement(name),          do: "self.#{name} = #{name}"
  def emitCtorParam(name, type),          do: "#{name}: #{type}"
  def emitArg(name),                      do: "#{name}: #{name}"
  def emitSequenceElement(name, type),    do: "@usableFromInline var #{name}: #{type}\n"

  def emitCtorBody(fields), do:
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         String.duplicate(" ", 8) <> emitCtorBodyElement(parseFieldName(fieldName))
       _ ->  ""
      end, fields), "\n")

  def emitEncoderBody(fields), do:
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         String.duplicate(" ", 12) <> emitEncoderBodyElement(parseFieldName(fieldName))
       _ ->  ""
      end, fields), "\n")

  def emitDecoderBody(name,fields), do:
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         String.duplicate(" ", 12) <>
         emitDecoderBodyElement(parseFieldName(fieldName),
                                substituteType(lookup(parseFieldType(name,fieldName,fieldType))))
       _ ->  ""
      end, fields), "\n")

  def emitParams(name,fields) when is_list(fields) do
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         emitCtorParam(parseFieldName(fieldName),
                       substituteType(lookup(parseFieldType(name,fieldName,fieldType))))
       _ ->  ""
      end, fields), ", ")
  end

  def emitArgs(fields) when is_list(fields) do
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         emitArg(parseFieldName(fieldName))
       _ ->  ""
      end, fields), ", ")
  end


  def emitSequenceDefinition(name,fields,ctor,decoder,encoder) do
"""
// This file is autogenerated. Do not edit.

import Foundation
import SwiftASN1
import Crypto

@usableFromInline struct #{name}: DERImplicitlyTaggable, Hashable, Sendable {
    @inlinable static var defaultIdentifier: ASN1Identifier { .sequence }\n#{fields}#{ctor}#{decoder}#{encoder}}
"""
  end

  def emitSequenceDecoder(fields, name, args), do:
"""
    @inlinable init(derEncoded root: ASN1Node,
        withIdentifier identifier: ASN1Identifier) throws {
        self = try DER.sequence(root, identifier: identifier) { nodes in\n#{fields}
            return #{normalizeName(name)}(#{args})
        }
    }
"""

  def emitSequenceEncoder(fields), do:
"""
    @inlinable func serialize(into coder: inout DER.Serializer,
        withIdentifier identifier: ASN1Identifier) throws {
        try coder.appendConstructedNode(identifier: identifier) { coder in\n#{fields}
        }
    }
"""

  def emitCtor(params,fields), do: "    @inlinable init(#{params}) {\n#{fields}\n    }\n"

  def emitFields(name, pad, fields) when is_list(fields) do
      Enum.join(:lists.map(fn 
       {:ComponentType,_,fieldName,{:type,_,fieldType,elementSet,[],:no},optional,_,_} ->
         field = parseFieldType(name, fieldName, fieldType)
         String.duplicate(" ", pad) <>
         emitSequenceElement(parseFieldName(fieldName),
                             substituteType(lookup(field)))
       _ ->  ""
      end, fields), "")
  end

  def compile_all() do # 2-passes for name resolving
      {:ok, files} = :file.list_dir dir()
      :lists.map(fn file -> compile(false, dir() <> :erlang.list_to_binary(file))  end, files)
      :lists.map(fn file -> compile(true,  dir() <> :erlang.list_to_binary(file))  end, files)
      :ok
  end

  def save(flag, name, res) do
      case flag do
           true -> 
               file = normalizeName(name) <> ".swift"
               :logger.info 'write: ~p', [file]
               :file.write_file file, res
           false -> []
      end
  end

  def compileType(pos, name, typeDefinition, save \\ true) do
      case typeDefinition do
           {:type, _, {:SEQUENCE, _, _, _, fields}, _, _, :no} -> 
               save(save, name, emitSequenceDefinition(normalizeName(name),
                   emitFields(name, 4, fields), emitCtor(emitParams(name,fields), emitCtorBody(fields)),
                   emitSequenceDecoder(emitDecoderBody(name, fields), name, emitArgs(fields)),
                   emitSequenceEncoder(emitEncoderBody(fields))))
           {:type, _, {:CHOICE, type}, [], [], :no} ->
               :skip
           {:type, _, {:ENUMERATED, type}, [], [], :no} ->
               :skip
           {:type, x, :INTEGER, [], [], :no} ->
               :application.set_env(:asn1scg, bin(name), "INTEGER")
               :skip
           {:type, _, {:INTEGER, file}, [], [], :no} ->
               :skip
           {:type, _, {:"SEQUENCE OF", type}, [], [], :no} ->
               :skip
           {:type, _, :"OCTET STRING", [], [], :no} ->
               :application.set_env(:asn1scg, bin(name), "OCTET STRING")
               :skip
           {:type, _, :"BIT STRING", [], [], :no} ->
               :application.set_env(:asn1scg, bin(name), "BIT STRING")
               :skip
           {:type, _, {:"BIT STRING",_}, [], [], :no} ->
               :application.set_env(:asn1scg, bin(name), "BIT STRING")
               :skip
           {:type, _, {:"SET OF", type}, elementSet, [], :no} ->
               :skip
           {:type, _, :"OBJECT IDENTIFIER", _, _, :no} -> 
               :skip
           {:type, _, {:ObjectClassFieldType, _, _, _, fields}, _, _, :no} -> 
               :logger.info('ASN.1 name ~p type ~p is not supported.', [name, typeDefinition])
               :skip
           {:type, _, {:Externaltypereference, _, _, name}, [], [], _} ->
               :skip
           {:type, _, {:pt, _, _}, [], [], _} ->
               :skip
           {:ObjectSet, _, _, _, elementSet} ->
               :skip
           {:Object, _, val} -> 
               :skip
           {:Object, _, _, _} -> 
               :skip
           file ->
               :logger.info 'unknown: ~p ~p', [name, file]
               :skip
      end 
  end

  def normalizeName(name), do: Enum.join(String.split("#{name}", "-"), "")
  def lookup(name), do: bin(:application.get_env(:asn1scg, bin(name), bin(name)))
  def bin(x) when is_atom(x), do: :erlang.atom_to_binary x
  def bin(x) when is_list(x), do: :erlang.list_to_binary x
  def bin(x), do: x

  def dumpValue(pos, name, type, value, mod), do: []
  def dumpClass(pos, name, mod, type), do: []
  def dumpPType(pos, name, args, type), do: []
  def dumpModule(pos, name, defid, tagdefault, exports, imports), do: []

  def compile(save, file \\ "priv/proto/CHAT.asn1") do
      tokens = :asn1ct_tok.file file
      {:ok, mod} = :asn1ct_parser2.parse file, tokens
      {:module, pos, name, defid, tagdefault, exports, imports, _, typeorval} = mod
      :lists.map(fn
         {:typedef,  _, pos, name, type} -> compileType(pos, name, type, save)
         {:ptypedef, _, pos, name, args, type} -> dumpPType(pos, name, args, type)
         {:classdef, _, pos, name, mod, type} -> dumpClass(pos, name, mod, type)
         {:valuedef, _, pos, name, type, value, mod} -> dumpValue(pos, name, type, value, mod)
      end, typeorval)
      dumpModule(pos, name, defid, tagdefault, exports, imports)
  end

end
