defmodule CHAT.X509 do
    require CHAT

    def ctx(),  do: :application.get_env(:chat, :ctx, ["010-WELCOME"])
    def home(), do: :application.set_env(:chat, :ctx, ["010-WELCOME"])

    def back() do
        case ctx() do
             [] -> home()
             [_ctx] -> :skip
             ctx -> :application.set_env(:chat, :ctx, tl(ctx))
        end
    end

    def push(name) do
        ctx = ctx()
        newCtx = [name|ctx]
        :application.set_env(:chat, :ctx, newCtx)
    end

    def findScreen(name) do
        {_,screen} = :lists.keyfind(name, 1, list())
        screen
    end

    def next(no) do
        [ctx|_] = ctx()
        CHAT.screen(sections: [CHAT.section(name: _name, rows: rows)]) = findScreen(ctx)
        CHAT.row(rico: {:more, nextName}) = :lists.keyfind(no,2,rows)
        push(nextName)
        show()
    end

    def rico("toggle"), do: :toggle
    def rico("pin"), do: :pin
    def rico("[]"), do: []
    def rico("bin"), do: :bin
    def rico("text"), do: :text
    def rico("search"), do: :search
    def rico("export"), do: :export
    def rico(name), do: {:more, name}

    def list() do
        {:ok, bin} = :file.read_file "forms.txt"
        screens = String.split bin, "\n\n"
        :lists.map(fn screen ->

          lines = String.split screen, "\n"
          name = hd(lines)
          rows = tl(lines)
          section = tl(String.split hd(rows), " ")
          sc = hd(String.split name, "-")

          { name,
            CHAT.screen(no: :erlang.binary_to_integer(sc), name: name, sections: [
              CHAT.section(name: Enum.join(section, " "), rows: :lists.map(fn row -> 
                 no = hd(String.split(row, " "))
                 rest = tl(String.split(row, " "))
                 rico = hd(:lists.reverse(rest))
                 desc = Enum.join :lists.reverse(tl(:lists.reverse(rest))), " "
                 CHAT.row(no: no, desc: desc, rico: rico(rico))
              end, tl(rows))) ])
          }

        end, screens)
    end

    def show() do
        [ctx|_] = ctx()
        CHAT.screen(sections: [CHAT.section(name: name, rows: rows)]) = findScreen(ctx)
        :io.format '\e[0m\e[1;97m\e[45m    \e[0;97m\e[1;104m ~ts ~n\e[0m\e[0K', [name]
        :lists.map(fn CHAT.row(no: no, desc: desc, rico: _rico) ->
           :io.format '\e[0m\e[1;97m\e[45m ~2.. B \e[0;93m\e[0;104m ~40.. ts ~n\e[0m\e[0K', [no,desc]
        end, rows)
        :ok
    end

    def gen() do
        bin = "// This file is autogenerated. Do not edit.\n" <>
        "public class App {\n" <>
        "  public static var screens: [Form.screen] = [\n" <>

        :lists.foldl(fn {name,screen}, acc ->
           acc <> gen(name, screen)
        end, <<>>, list())

        <> "   ]\n"
        <> "}\n"
        :file.write_file "app.swift", bin
    end

    def gen(name, screen) do
        CHAT.screen(sections: [CHAT.section(name: name, rows: rows)]) = findScreen(name)
              "    Form.screen(\n"
           <> "      no: " <> :erlang.integer_to_binary(CHAT.screen(screen, :no)) <> ",\n"
           <> "      name: \"" <> CHAT.screen(screen, :name) <> "\",\n"
           <> "      sections: [" <> "\n"
           <> "        Form.section(name: \"#{name}\"," <> "\n"
           <> "          rows: [ " <>
             :lists.foldl(fn x, acc -> 
                no = CHAT.row(x, :no)
                desc = CHAT.row(x, :desc)
                rico = case CHAT.row(x, :rico) do
                   {:more,next} -> "(\"more\",\"#{next}\")"
                   _ -> "(\"more\",\"\")"
                end
                acc <> "\n            Form.row(no: #{no}, desc: \"#{desc}\", rico: #{rico}), "
             end, <<>>, rows) <> " ]) ]),\n"
     end

     def test do
         :CHAT.encode(:CHATMessage,
         CHAT."CHATMessage"(no: 1, headers: [], body: {:message,
         CHAT."Message"(id: "5HT", feed: {:muc,CHAT."MUC"(room: "1")},
                        signature: "", from: "sys", to: "5HT", created: 1,
                        files: [], type: :sys, link: {:empty,"NULL"},
                        seenby: "", repliedby: "", mentioned: [])}))
     end

end